# 백엔드 기능 및 로직

## 1. AI 도서 추천

- 모델 선정 이유: GPT-4o-mini는 비용에 비해 텍스트 분석 성능이 뛰어남, 또한 응답속도가 빠름. 실제 서비스를 운영할 때 중요한 것은 운영 비용과 속도-> 사용자 UX 고려
- (1) 독서 취향을 알 수 있는 10가지의 퀴즈
- (2) 후보군 필터링: DB 상에 존재하는 도서 중, 사용자가 선택한 장르의 상위 20개의 도서를 후보군으로 AI에게 전달함.
- (3) 프롬프트 엔지니어링 및 JSON 파싱: ChatGPT-4o-mini API에게 사용자 페르소나 데이터와 후보 도서 목록, 개발자가 사전에 입력한 양식을 주고 JSON 형식으로 응답하게 설계
- 프롬프트 엔지니어링:
- (1) 역할 부여(Role Prompting) : AI에게 페르소나 부여
- (2)컨텍스트 제한 (Few-Shot & Context Injection): 현재 웹서버 내의 DB 데이터만 참고하게 함 + 추천 코멘트 예시를 제시하여 원하는 문장 구조를 출력하도록 프롬프트 제공. -> 할루시네이션 방지
- (3) 출력 형식 강제(Output Structuring): 답변을 JSON 규격으로 강제하여, 바로 데이터를 저장, 렌더링할 수 있게 함.
- 시간이 된다면, DB상에 저장된 추천 데이터를 기반으로 메인페이지 구성/재추천 로직/모임 추천 로직을 보강하고 싶음.

## 2. 실시간 채팅 서비스

- 참여자 확인: redis의 Set()자료구조를 확인하여 참여상태를 확인함. 입장, 퇴장시 set에서 유저의 정보를 add/remove함. (1) set을 사용함으로써 동일한 user id를 받아도 참여자 수가 중복되지 않고 확실히 알 수 있음. / (2) 탐색 속도가 O(1)임
- 백엔드 병목현상 해결: 웹소켓은 비동기인 반면, Django ORM은 동기적임. 웹소켓과 ORM을 동시에 사용할 경우 CPU를 점유하여 채팅서비스가 정지될 수 있음. 이를 해결하기 위해 @database_sync_to_async 데코레이터를 활용하여 ORM을 위한 별도 스레드를 생성하고, 멀티스레딩 방식으로 작동하게 함.
- 백엔드 레벨 보안 검증: 로그인하지 않은 유저/참여하지 않은 유저/미팅시간 전후로 미팅 정보와 사용자의 정보를 점검하여 이중보안을 적용함.

## (1) 메세지 송수신

- 기본적으로 로그인→참여/모임 개설 여부를 확인함. 채팅방 링크를 클릭하면, JS에서 connect 함수를 통해 해당 유저의 Consumer를 해당 채널 그룹에 추가함. 채팅방은 미팅 시작-종료 시간 동안에만 활성화됨.
- 메세지를 작성 시, 해당 메세지는 JSON 규격의 데이터에 담김. 서버는 메세지를 받아 누가 보냈는지(id, nickname)을 붙여 레디스를 통해 해당 방에 접속한 유저에게 모두 뿌림.
- JS의 renderMessage를 통해 모든 참여자의 브라우저에 메세지가 도착함. 메세지의 user_id=currendUserId 비교를 통해 내가 보낸 메세지와 타인이 보낸 메세지를 구분하여 말풍선을 그린다.

## (2) 참여자 상태 확인

- 백엔드 상에서 미팅의 개설자, 참여자를 모두 합친 participants_list를 만듦. 중복 방지를 위해 Python Dictionary 구조를 활용함.
- JS에서는 서버에서 전송한 participants_list상에서 유저의 online 값이 true라면 초록색, 아니라면 회색 글자로 명단을 보여줌. 리더라면 왕관을 붙임.

## (3) 퇴장

- 유저가 해당 url에서 나가면 ChatConsumer의 disconnect 함수가 실행됨.
- 서버는 redis에서 해당 유저의 접속 정보를 삭제, 남은 사람들에게 “누가 나갔다”는 시스템 메세지+참여자 명단을 보냄.
- 서버 문제로 끊겼다면, JS의 setTimeout로직을 통해 3초 뒤 재연결을 시도함.

————————————————————————

## 3. 실시간 알람 서비스

- (1) 셀러리 비트(backend-celery): 스케줄러로, beat_schedule을 통해 10초마다 한번씩 db를 확인하라고 셀러리 워커에게 명령을 보냄.
- (2) 셀러리 워커(tasks->send today meeting alarms for today): 현재 시간을 기준으로 started_at이 10분 전인 미팅들을 조회. 해당 미팅의 참여자/리더를 조회하고, 해당 유저들에게 보낼 메세지를 생성함.
- (3) 레디스: 워커가 알람 내용을 redis로 보내면, group_send를 통해 생성된 웹소켓 그룹에 전체 메세지를 전송함. 이때, http연결이 아닌 실시간 websocket 연결로 알람을 보내기 때문에 새로고침 없이 알람을 받을 수 있다.

- ? 왜 레디스 씀?: celery-Django Channels사이에서 메세지를 전달해주는 역할을 위해서 씀. 레디스는 속도가 매우 빨라 실시간 알람 및 채팅 서비스에 적합함.
- ? 메세지 브로커가 뭐냐?: 서로 다른 프로그램(장고-셀러리)가 대화할 수 있게 중계해주는 역할
- ? 레디스가 메모리기반 저장소라며. 그건 뭔데?: 일단 DB는 하드디스크에 정보를 저장해 조회 속도가 느림. 메모리 기반의 경우 램에 저장해, 조회가 빠르지만 전원 off 시 데이터가 휘발된다는 단점이 있음.
- ? 서버 안 느려짐?: 알람 조회->발송은 Celery Worker라는 프로세스에서 처리되고, Django web server와는 완전히 분리되어 있음.
- ? 왜 10초? 실시간 채팅 서비스의 정시 시작이 서비스 신뢰도의 핵심이다~ 시작 알람을 놓치지 않고 즉시 받아볼 수 있게 설계함
- ? 셀러리말고 장고 APScheduler 쓰면 안됨? 장고 내부 스케줄러는 웹서버의 자원을 공유하기 때문에, 여러 유저에게 알람을 전송 시 채팅 서비스가 느려질 수 있다. 셀러리는 웹서버와 완전히 분리되기 때문에 안정성이 확보된다.
- -> 시간이 된다면 몽고DB에 채팅 로그를 저장하는 방식으로 redis의 단점을 보완하고 싶었다~ 몽고디비는 대용량 데이터 저장/분산/단순 데이터 저장에 특화되어 있어서 카카오톡이나 다른 대규모 서비스에서 많이 사용함.
——————————

## 4. railway를 통한 배포 (redis, postgreSQL, Django+websocket+docker)

- 배포 이유 : 처음에는 실시간 채팅 시연을 위해 Ngrok을 활용한 외부 서버 호스팅을 시도했지만, 무료 플랜의 경우 도메인이 계속 변경됨+프론드엔드 프레임워크와의 연동+웹소켓 연결의 불안정성의 이유로 railway기반의 백엔드 배포로 변경.
- Railway 선정 이유 : 해당 프로젝의 경우, HTTP 요청 뿐만 아니라 실시간 연결을 요청하는 웹소켓 연결 역시 처리할 수 있어야 함. 깃허브 연동을 통한 빠른 CICD 가능 + 간편한 서버 설치 및 네트워크 설정 + 웹소켓 연동 지원(Daphne)를 이유로 레일웨이 선택.
- 단점은 SQLite를 PostgreSQL로 이식해야한다는 점과 대형 서비스라면 비용이 많이 들 수 있다는 점. PostgreSQL 이식의 경우, Gemini를 사용하여 기존 DB 상의 데이터를 dumpdata하여 바로 이식할 수 있어, 생각보다 시간이 많이 걸리지는 않았음.
-> 시간이 허락한다면 AWS EC2+Docker 로 배포하고 싶었다. Docker를 통해 Django+Redis를 한 서버에서 배포할 수 있기 때문이지만, 서버 다운 시 재빌드 및 보안/인증서 로직을 직접 설정해야한다는 번거로움이 있어서 못했음!

————————

## AI 활용:

- SQLite->PostgreSQL DB 이식 과정에서 Gemini를 활용해 데이터 덤프와 스키마 마이그레이션 시간을 단축함
- 알라딘 API에서 받은 데이터를 파싱하여 DB에 바로 삽입할 수 있게, 다양한 예외 케이스(도서 모임에 적합하지 않은 장르/저자가 여러명인 경우 등)를 한 번에 처리하도록 파싱 코드를 작성.

———————

## 알라딘 API를 활용한 도서 데이터 저장

1. 베스트 셀러 100권을 알라딘 상품 검색 API를 통해 가져옴.
2. split을 활용하여 카테고리를 서비스에 맞게 중분류를 기준으로 단순화함.
3. 정제된 데이터를 장고가 바로 인식할 수 있게 JSON fixture로 변환하여 저장.
4. 도서를 저장할 때, 카테고리와 저자는 set과 map을 통해 저장하여, 중복 데이터를 방지 / 정규화 원칙을 지킴.
5. 어린이 / 만화 / 외국어 등 독서 모임의 성격에 맞지 않는 카테고리의 책을 제외함.
